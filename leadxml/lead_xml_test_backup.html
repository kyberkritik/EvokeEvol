<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Evoke Evol ‚Äî Multi-Part XML Player</title>
<style>
body{
  background:#0b0f14;
  color:#cfe8ff;
  font-family:"IBM Plex Mono", monospace;
  text-align:center;
  padding:2rem;
}
button{
  background:linear-gradient(180deg,#1b2a3a,#0d1826);
  border:none;
  color:#cfe8ff;
  border-radius:12px;
  padding:1rem 2rem;
  font-size:1.1rem;
  cursor:pointer;
  box-shadow:0 0 12px rgba(78,169,255,.3);
}
button:hover{color:#10b981;}
h1{color:#10b981;}
</style>
</head>
<body>
<button onclick="window.location.href='../index.html'" style="position:absolute;top:20px;left:20px;font-size:0.9rem;">‚Üê Inicio</button>
<h1>:Evoke Evol: ‚Äî Multi-Part XML Player</h1>
<p>Plays both tracks from <code>newokt25midi.xml</code> - Analog Spheres & Contemporary Soul.</p>

<div style="margin: 2rem 0;">
  <button id="play">‚ñ∂ Play Composition</button>
  <button id="stop" style="margin-left:1rem;">‚èπ Stop</button>
  <button id="switchSounds" style="margin-left:1rem;">üîÑ Switch Sounds</button>
  <div style="margin-top: 1rem;">
    <label>
      <input type="checkbox" id="loopMode" checked> 
      üîÅ Loop Mode
    </label>
  </div>
  <p id="status" style="margin-top:1rem;opacity:0.7;font-size:0.9rem;">Ready to play your multi-part composition</p>
</div>

<div style="margin: 2rem auto; max-width: 600px; background: rgba(255,255,255,0.05); padding: 1.5rem; border-radius: 12px;">
  <h3 style="margin-top: 0; color: #10b981; text-align: center;">üéº Composition Info</h3>
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; text-align: center;">
    <div style="background: rgba(78,169,255,0.1); padding: 1rem; border-radius: 8px;">
      <h4 style="color: #4ea9ff; margin: 0 0 0.5rem 0;">Part 1</h4>
      <p style="margin: 0; font-size: 0.9rem;">Analog Spheres</p>
      <small id="part1Sound" style="opacity: 0.7;">Square/Triangle waves</small>
    </div>
    <div style="background: rgba(16,185,129,0.1); padding: 1rem; border-radius: 8px;">
      <h4 style="color: #10b981; margin: 0 0 0.5rem 0;">Part 2</h4>
      <p style="margin: 0; font-size: 0.9rem;">Contemporary Soul</p>
      <small id="part2Sound" style="opacity: 0.7;">Sine waves</small>
    </div>
  </div>
  <div style="text-align: center; margin-top: 1rem; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 6px;">
    <small style="opacity: 0.6;">Click "Switch Sounds" to swap the wave types between parts</small>
  </div>
</div>

<script>
// Audio system with sound switching and loop capability
let audioCtx = null;
let isPlaying = false;
let audioNodes = [];
let loopTimeout = null;
let loadedParts = null;
let soundsSwapped = false; // Track if sounds are swapped

// Convert MusicXML pitch to frequency
function pitchToFreq(step, alter, octave){
  const pitchMap = {C:0, D:2, E:4, F:5, G:7, A:9, B:11};
  const semitone = pitchMap[step] + (alter || 0);
  const midi = 12 * (octave + 1) + semitone;
  return 440 * Math.pow(2, (midi - 69) / 12);
}

// Update sound display
function updateSoundDisplay() {
  const part1Elem = document.getElementById('part1Sound');
  const part2Elem = document.getElementById('part2Sound');
  
  if(soundsSwapped) {
    part1Elem.textContent = 'Sine waves';
    part2Elem.textContent = 'Square/Triangle waves';
  } else {
    part1Elem.textContent = 'Square/Triangle waves';
    part2Elem.textContent = 'Sine waves';
  }
}

// Initialize audio system
function initAudio(){
  if(!audioCtx || audioCtx.state === 'closed'){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  return audioCtx;
}

// Stop all audio
function stopAllAudio(){
  audioNodes.forEach(node => {
    try {
      if(node.stop) node.stop();
    } catch(e) {}
  });
  audioNodes = [];
  isPlaying = false;
  
  // Clear loop timeout
  if(loopTimeout) {
    clearTimeout(loopTimeout);
    loopTimeout = null;
  }
}

// Switch sounds between parts
function switchSounds() {
  soundsSwapped = !soundsSwapped;
  updateSoundDisplay();
  
  // If currently playing, restart with new sounds
  if(isPlaying) {
    stopAllAudio();
    setTimeout(() => {
      playComposition();
    }, 100);
  }
}

// Parse multi-part XML file
async function loadMultiPartXML(url){
  const res = await fetch(url);
  const text = await res.text();
  const xml = new DOMParser().parseFromString(text, "application/xml");
  
  // Get divisions for timing calculation
  const divisions = parseInt(xml.querySelector("divisions")?.textContent || 4);
  
  // Get all parts
  const parts = Array.from(xml.querySelectorAll("part"));
  console.log(`Found ${parts.length} parts in ${url}`);
  
  const allParts = [];
  
  parts.forEach((part, partIndex) => {
    const partId = part.getAttribute("id");
    const noteEls = Array.from(part.querySelectorAll("note"));
    let notes = [];
    let currentTime = 0;
    
    console.log(`Processing part ${partId}: ${noteEls.length} note elements`);
    
    noteEls.forEach((noteEl) => {
      const isChord = noteEl.querySelector("chord") !== null;
      const isRest = noteEl.querySelector("rest") !== null;
      
      if(!isRest) {
        const step = noteEl.querySelector("step")?.textContent;
        const octave = parseInt(noteEl.querySelector("octave")?.textContent || 4);
        const alter = parseInt(noteEl.querySelector("alter")?.textContent || 0);
        const duration = parseFloat(noteEl.querySelector("duration")?.textContent || 1);
        
        if(step) {
          notes.push({
            time: currentTime / divisions,
            step, 
            octave, 
            alter, 
            duration: duration / divisions,
            isChord,
            partId
          });
        }
      }
      
      // Only advance time if this is NOT a chord note
      if(!isChord) {
        const duration = parseFloat(noteEl.querySelector("duration")?.textContent || 1);
        currentTime += duration;
      }
    });
    
    allParts.push({
      id: partId,
      notes: notes,
      name: getPartName(xml, partId)
    });
    
    console.log(`Part ${partId} (${getPartName(xml, partId)}): ${notes.length} notes`);
  });
  
  return allParts;
}

// Get part name from XML
function getPartName(xml, partId) {
  const scorePart = xml.querySelector(`score-part[id="${partId}"]`);
  return scorePart?.querySelector("part-name")?.textContent || partId;
}

// Calculate total composition duration
function calculateDuration(parts) {
  let maxDuration = 0;
  parts.forEach(part => {
    part.notes.forEach(note => {
      const endTime = note.time + note.duration;
      if(endTime > maxDuration) {
        maxDuration = endTime;
      }
    });
  });
  return maxDuration * (60/120) * 1000; // Convert to milliseconds at 120 BPM
}

// Play all parts from the multi-part XML
async function playComposition(){
  try {
    initAudio();
    if(audioCtx.state === "suspended") await audioCtx.resume();
    
    stopAllAudio(); // Stop any currently playing audio
    
    // Load the multi-part XML file if not already loaded
    if(!loadedParts) {
      loadedParts = await loadMultiPartXML("newokt25midi.xml");
    }
    
    isPlaying = true;
    const start = audioCtx.currentTime + 0.5;
    const tempo = 120; // BPM from XML
    const beat = 60/tempo; // Quarter note duration in seconds
    
    console.log(`Playing ${loadedParts.length} parts in sync (sounds swapped: ${soundsSwapped})`);
    
    // Play each part
    loadedParts.forEach((part, partIndex) => {
      console.log(`Starting playback of part ${part.id} (${part.name})`);
      
      // Group notes by time to handle chords properly
      const noteGroups = {};
      part.notes.forEach(note => {
        const timeKey = note.time.toFixed(3);
        if(!noteGroups[timeKey]) {
          noteGroups[timeKey] = [];
        }
        noteGroups[timeKey].push(note);
      });

      // Play each time group for this part
      Object.keys(noteGroups).forEach(timeKey => {
        const noteGroup = noteGroups[timeKey];
        const playTime = parseFloat(timeKey);
        
        noteGroup.forEach((note, i) => {
          const freq = pitchToFreq(note.step, note.alter, note.octave);
          const osc = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          
          // Determine wave type based on part and swap state
          let isLeadPart, isPadPart;
          
          if(!soundsSwapped) {
            // Normal: Part 0 = lead, Part 1+ = pads
            isLeadPart = (partIndex === 0);
            isPadPart = (partIndex > 0);
          } else {
            // Swapped: Part 0 = pads, Part 1+ = lead
            isLeadPart = (partIndex > 0);
            isPadPart = (partIndex === 0);
          }
          
          if(isLeadPart) {
            // Lead-like sound
            osc.type = i === 0 ? "square" : "triangle";
          } else if(isPadPart) {
            // Pad-like sound
            osc.type = "sine";
          }
          
          osc.frequency.value = freq;
          
          // Volume based on part role and chord size
          const baseVolume = isLeadPart ? 0.15 : 0.1;
          const volume = noteGroup.length > 1 ? baseVolume / Math.sqrt(noteGroup.length) : baseVolume;
          
          // Add envelope for more musical sound
          const t = start + playTime * beat;
          const duration = note.duration * beat;
          
          g.gain.setValueAtTime(0, t);
          g.gain.linearRampToValueAtTime(volume, t + 0.02);
          
          if(isLeadPart) {
            // Lead part - shorter decay
            g.gain.exponentialRampToValueAtTime(0.001, t + duration * 0.8);
          } else {
            // Pad parts - longer sustain
            g.gain.setValueAtTime(volume * 0.7, t + duration * 0.7);
            g.gain.exponentialRampToValueAtTime(0.001, t + duration);
          }
          
          osc.connect(g).connect(audioCtx.destination);
          osc.start(t);
          osc.stop(t + duration);
          
          // Store reference for stopping
          audioNodes.push(osc);
        });
      });
    });
    
    console.log("All parts started in sync");
    
    // Calculate actual duration and set up loop or stop
    const duration = calculateDuration(loadedParts);
    const loopEnabled = document.getElementById("loopMode").checked;
    
    loopTimeout = setTimeout(() => {
      if(isPlaying) {
        if(loopEnabled) {
          // Restart composition for loop
          console.log("Looping composition...");
          playComposition();
        } else {
          // Stop after one play
          stopAllAudio();
          document.getElementById("play").textContent = "‚ñ∂ Play Composition";
          document.getElementById("status").textContent = "Playback completed";
        }
      }
    }, duration + 500); // Add small buffer
    
  } catch(error) {
    console.error("Playback error:", error);
    throw error;
  }
}

// Event listeners with sound switching and loop support
document.getElementById("play").onclick = async () => {
  const button = document.getElementById("play");
  const status = document.getElementById("status");
  const loopMode = document.getElementById("loopMode").checked;
  
  try {
    button.textContent = "Loading...";
    button.disabled = true;
    
    if(!loadedParts) {
      status.textContent = "Loading and parsing newokt25midi.xml...";
    } else {
      status.textContent = "Starting playback...";
    }
    
    await playComposition();
    
    button.textContent = "‚ô™ Playing...";
    const modeText = loopMode ? " (Looping)" : "";
    const swapText = soundsSwapped ? " [Sounds Swapped]" : "";
    status.textContent = `Playing both parts: Analog Spheres + Contemporary Soul${modeText}${swapText}`;
    
  } catch(error) {
    console.error("Playback error:", error);
    button.textContent = "‚ñ∂ Play Composition";
    button.disabled = false;
    status.textContent = "Error: " + error.message;
  }
};

document.getElementById("stop").onclick = () => {
  stopAllAudio();
  document.getElementById("play").textContent = "‚ñ∂ Play Composition";
  document.getElementById("play").disabled = false;
  document.getElementById("status").textContent = "Playback stopped";
};

document.getElementById("switchSounds").onclick = () => {
  switchSounds();
  const swapText = soundsSwapped ? " [Sounds Swapped]" : " [Sounds Normal]";
  if(!isPlaying) {
    document.getElementById("status").textContent = `Sounds switched${swapText}`;
  }
};

// Initialize sound display
updateSoundDisplay();
</script>
</body>
</html>